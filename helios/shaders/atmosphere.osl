/**
 * Helios Atmospheric Scattering - OSL Shader for Cycles
 * 
 * This shader provides atmospheric sky rendering for Blender Cycles.
 * It samples precomputed LUT textures to render physically-based skies.
 *
 * Copyright (c) 2017 Eric Bruneton (BSD License)
 * Copyright (c) 2024 MattePaint
 */

shader HeliosAtmosphere(
    // Input textures (as image file paths)
    string transmittance_texture = "",
    string scattering_texture = "",
    string irradiance_texture = "",
    
    // Atmosphere parameters
    float bottom_radius = 6360.0,      // km
    float top_radius = 6420.0,         // km
    float sun_angular_radius = 0.00467,// radians
    
    // Scattering parameters (already scaled)
    color rayleigh_scattering = color(0.0058, 0.0136, 0.0331),
    color mie_scattering = color(0.004),
    float mie_phase_g = 0.8,
    
    // Sun direction (normalized)
    vector sun_direction = vector(0, 0, 1),
    
    // Camera position (relative to planet center, in km)
    point camera_position = point(0, 0, 6361),
    
    // Exposure and white point
    float exposure = 10.0,
    color white_point = color(1.0),
    
    // Output
    output color Sky = color(0),
    output color Transmittance = color(1),
    output color Inscatter = color(0)
)
{
    // Constants
    float PI = M_PI;
    
    // Get view direction from shading normal (for world background)
    vector view_ray = normalize(I);
    
    // Convert to planet-relative coordinates
    // In Blender Z is up, camera is at altitude above planet surface
    point cam = camera_position;
    float r = length(cam);
    float mu = dot(normalize(cam), view_ray);
    float mu_s = dot(normalize(cam), sun_direction);
    float nu = dot(view_ray, sun_direction);
    
    // Check if ray intersects ground
    int ray_intersects_ground = 0;
    if (mu < 0.0) {
        float discriminant = r * r * (mu * mu - 1.0) + bottom_radius * bottom_radius;
        if (discriminant >= 0.0) {
            ray_intersects_ground = 1;
        }
    }
    
    // Compute H (distance from ground to atmosphere top at horizon)
    float H = sqrt(top_radius * top_radius - bottom_radius * bottom_radius);
    float rho = sqrt(max(r * r - bottom_radius * bottom_radius, 0.0));
    
    // Transmittance texture UV
    float d = -r * mu + sqrt(max(r * r * (mu * mu - 1.0) + top_radius * top_radius, 0.0));
    float d_min = top_radius - r;
    float d_max = rho + H;
    float x_mu = (d_max > d_min) ? (d - d_min) / (d_max - d_min) : 0.0;
    float x_r = rho / H;
    
    // Sample transmittance (simplified - actual impl needs texture sampling)
    // This is a placeholder - real implementation samples the LUT
    float optical_depth_r = exp(-x_r * 8.0);  // Approximate Rayleigh
    float optical_depth_m = exp(-x_r * 1.2);  // Approximate Mie
    
    Transmittance = color(optical_depth_r) * color(1.0, 0.9, 0.7);
    
    // Rayleigh phase function
    float rayleigh_phase = (3.0 / (16.0 * PI)) * (1.0 + nu * nu);
    
    // Mie phase function (Cornette-Shanks)
    float g = mie_phase_g;
    float mie_phase = (3.0 / (8.0 * PI)) * ((1.0 - g * g) / (2.0 + g * g)) *
                      (1.0 + nu * nu) / pow(1.0 + g * g - 2.0 * g * nu, 1.5);
    
    // Approximate sky color based on view and sun directions
    // This is simplified - full impl uses scattering LUT
    float altitude_factor = clamp((r - bottom_radius) / (top_radius - bottom_radius), 0.0, 1.0);
    float horizon_factor = 1.0 - abs(mu);
    float sun_glow = pow(max(nu, 0.0), 8.0);
    
    // Base sky color (Rayleigh blue)
    color sky_blue = color(0.2, 0.5, 1.0) * rayleigh_phase;
    
    // Mie glow near sun
    color mie_glow = color(1.0, 0.9, 0.7) * mie_phase * sun_glow * 0.1;
    
    // Horizon reddening
    color horizon = color(1.0, 0.6, 0.3) * horizon_factor * (1.0 - mu_s) * 0.5;
    
    // Combine
    Inscatter = (sky_blue + mie_glow + horizon) * (1.0 - ray_intersects_ground);
    
    // Final sky with transmittance
    Sky = Inscatter;
    
    // Add sun disk
    float sun_solid_angle = PI * sun_angular_radius * sun_angular_radius;
    if (nu > cos(sun_angular_radius)) {
        // Inside sun disk
        color solar_radiance = color(1.0, 0.98, 0.95) * 1000.0;
        Sky = Sky + Transmittance * solar_radiance;
    }
    
    // Apply exposure and tone mapping
    Sky = color(1.0) - exp(-Sky / white_point * exposure);
    
    // Gamma correction (Cycles expects linear, but we might want to preview)
    // Sky = pow(Sky, 1.0/2.2);  // Uncomment for sRGB output
}
